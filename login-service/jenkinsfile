def SERVICE_NAME = 'login-service'  // adapter √† chaque fichier


pipeline {
    
    agent any

    environment {
//        SONAR_TOKEN   = credentials('sonarqube_token-login')
        SONARQUBE     = 'sonarqube_devops_master_analyse'
        NVD_API_KEY   = credentials('nvd-api-key')
        IMAGE_NAME    = "hamidbong/login-service"
    }

    stages {

        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Install & Test') {
            parallel {
                stage('Install & Generate Lock') {
                    steps {
                        dir('login-service') {
                            sh 'npm ci --no-audit'
                            sh 'rm -f package-lock.json && npm install --package-lock-only --no-audit'
                        }
                    }
                }
                stage('Run Tests') {
                    steps {
                        dir('login-service') {
                            sh 'npm test -- --coverage'
                        }
                    }
                }
            }
        }
        

        



        stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv("${SONARQUBE}") {
                    withCredentials([string(credentialsId: 'sonarqube_token-login', variable: 'SONAR_TOKEN')]) {
                        script {
                            def nodePath = sh(returnStdout: true, script: 'which node').trim()

                            sh """
                                ${tool('SonarScanner')}/bin/sonar-scanner \
                                    -Dsonar.projectKey=ci-cd-npm-node \
                                    -Dsonar.projectName=${SERVICE_NAME} \
                                    -Dsonar.projectVersion=${env.BUILD_NUMBER} \
                                    -Dsonar.sources=${SERVICE_NAME} \
                                    -Dsonar.nodejs.executable=${nodePath} \
                                    -Dsonar.javascript.lcov.reportPaths=${SERVICE_NAME}/coverage/lcov.info
                            """
                        }
                    }
                }
            }
        }

        stage('Quality Gate') {
            steps {
                withCredentials([string(credentialsId: 'sonarqube_token-login', variable: 'SONAR_TOKEN')]) {
                    retry(3) {
                        timeout(time: 1, unit: 'MINUTES') {
                            // Pass the token explicitly
                            waitForQualityGate abortPipeline: true, credentialsId: 'sonarqube_token-login'
                        }
                    }
                }
            }
        }

        /*stage('Quality Gate') {
            steps {
                retry(3) {
                    timeout(time: 1, unit: 'MINUTES') {
                        waitForQualityGate abortPipeline: true
                    }
                }
            }
        }*/
        stage('Trivy Filesystem Scan') {
            steps {
                dir('login-service') {
                    sh '''
                        docker run --rm \
                            -v $(pwd):/scan \
                            aquasec/trivy fs --security-checks vuln,config /scan
                    '''
                }
            }
        }

        stage('Docker Access Test') {
            steps {
                sh 'docker version'
            }
        }

        stage('Build Docker Image') {
            steps {
                dir('login-service') {
                    timeout(time: 15, unit: 'MINUTES') {
                        script {
                            dockerImage = docker.build("${IMAGE_NAME}:${env.BUILD_ID}")
                        }
                    }
                }
            }
        }

        stage('Setup Trivy Caches') {
            steps {
                sh 'docker volume create --name trivy_cache || true'
                sh 'docker volume create --name trivy_javadb_cache || true'
            }
        }

        stage('Scan with Trivy') {
            steps {
                script {
                    try {
                        sh '''
                            docker run --rm \
                                -v /var/run/docker.sock:/var/run/docker.sock \
                                -v trivy_cache:/root/.cache/trivy \
                                -v trivy_javadb_cache:/root/.cache/trivy-java-db \
                                -e TRIVY_TIMEOUT=30m \
                                -v $(pwd):/project \
                                aquasec/trivy:latest \
                                image ${IMAGE_NAME}:${BUILD_ID} \
                                --exit-code 1 \
                                --severity CRITICAL,HIGH \
                                --ignore-unfixed \
                                --timeout 30m \
                                --format json \
                                --output /project/trivy-report.json
                        '''

                    } catch (err) {
                        error "Trivy scan failed due to CRITICAL/HIGH vulnerabilities"
                    }
                }
                archiveArtifacts artifacts: 'trivy-report.json', allowEmptyArchive: true
            }
            post {
                failure {
                    error "‚ùå Trivy found CRITICAL/HIGH vulnerabilities!"
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                dir('login-service') {
                    script {
                        docker.withRegistry('https://index.docker.io/v1/', 'dockerHub-login') {
                            dockerImage.push()
                            dockerImage.push('latest')
                        }
                    }
                }
            }
        }
        stage('Cleanup Docker') {
            steps {
                script {
                    // Supprime l'image locale apr√®s le push
                    sh "docker rmi ${IMAGE_NAME}:${env.BUILD_ID} || true"
                    sh "docker rmi ${IMAGE_NAME}:latest || true"
                    
                    // Optionnel : Nettoyage des images "<none>" (dangling)
                    sh "docker image prune -f || true"
                }
            }
        }

        stage('Apply Kubernetes Files') {
            steps {
                withKubeConfig([credentialsId: 'kubeconfig']) {
                    sh """
                        cat k8s/login-service/deployment.yaml | \
                        sed "s/{{BUILD_NUMBER}}/${env.BUILD_ID}/g" | kubectl apply -f -
                        kubectl apply -f k8s/login-service/service.yaml
                        # kubectl apply -f k8s/ingress.yaml
                    """
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                withKubeConfig([credentialsId: 'kubeconfig']) {
                    sh 'kubectl rollout status deployment/login-deployment --timeout=300s'
                    sh 'kubectl wait --for=condition=ready pod -l app=login-service --timeout=300s'
                }
            }
        }
    }

    post {
        always {
            script {
                echo "üßæ Pipeline completed on build #${env.BUILD_NUMBER}"
                archiveArtifacts artifacts: 'login-service/coverage/**', allowEmptyArchive: true
            }
        }
        success {
            echo '‚úÖ Build succeeded!'
        }
        failure {
            echo '‚ùå Build failed!'
        }
    }
}
