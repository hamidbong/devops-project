def buildResults = [:]
def buildState = [services: [:]]

pipeline {
    agent any

    environment {
        SERVICES = 'service-node,service-python,frontend-react,service-java'
        BUILD_STATE_FILE = '.build-state.txt'
    }

    stages {
        stage('Pr√©paration') {
            steps {
                script {
                    // üîÅ Tentative de r√©cup√©ration de l'artefact pr√©c√©dent
                    try {
                        copyArtifacts(
                            projectName: env.JOB_NAME,
                            selector: lastSuccessful(),
                            filter: env.BUILD_STATE_FILE,
                            target: '.',
                            flatten: true
                        )
                        echo "‚úÖ Artefact r√©cup√©r√© avec succ√®s"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Impossible de restaurer l'artefact : ${e.message}"
                    }

                    // üîç D√©tection des fichiers modifi√©s via Git
                    def changedFiles = []
                    try {
                        // M√©thode plus robuste pour d√©tecter les changements
                        def changeLogSets = currentBuild.changeSets
                        if (changeLogSets && !changeLogSets.isEmpty()) {
                            changeLogSets.each { changeLogSet ->
                                changeLogSet.each { entry ->
                                    entry.affectedFiles.each { file ->
                                        changedFiles << file.path
                                    }
                                }
                            }
                        } else {
                            // Fallback: utiliser git diff
                            def gitDiff = sh(
                                script: 'git diff --name-only HEAD~1 HEAD 2>/dev/null || echo ""',
                                returnStdout: true
                            ).trim()
                            if (gitDiff) {
                                changedFiles = gitDiff.split('\n')
                            }
                        }
                        echo "üîç Fichiers modifi√©s d√©tect√©s : ${changedFiles}"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Erreur lors de la d√©tection des changements : ${e.message}"
                        changedFiles = []
                    }

                    // üß† Charger les services pr√©c√©demment en √©chec
                    def previousFailures = [] as Set
                    if (fileExists(env.BUILD_STATE_FILE)) {
                        def stateContent = readFile(env.BUILD_STATE_FILE).trim()
                        if (stateContent) {
                            stateContent.split('\n').each { line ->
                                def parts = line.split(':', 5)
                                if (parts.size() >= 2 && parts[1] == 'FAILURE') {
                                    previousFailures << parts[0]
                                }
                            }
                        }
                        echo "‚ö†Ô∏è Services pr√©c√©demment en √©chec : ${previousFailures}"
                    } else {
                        echo "‚ÑπÔ∏è Aucun fichier d'√©tat pr√©c√©dent trouv√©"
                    }

                    // üéØ D√©terminer les services affect√©s
                    def services = env.SERVICES.split(',').collect { it.trim() } as Set
                    def affectedServices = [] as Set

                    if (changedFiles) {
                        affectedServices = services.findAll { service ->
                            changedFiles.any { file -> 
                                file.startsWith("${service}/") || 
                                file.contains("/${service}/") ||
                                file.startsWith(service)
                            }
                        } as Set
                    }

                    // Ajouter les services pr√©c√©demment en √©chec
                    affectedServices.addAll(previousFailures)

                    // Si aucun service affect√©, builder tous les services
                    if (affectedServices.isEmpty()) {
                        echo "‚ÑπÔ∏è Aucun service affect√© d√©tect√©, construction de tous les services"
                        affectedServices = services
                    }

                    echo "üöÄ Services √† builder : ${affectedServices}"
                    env.AFFECTED_SERVICES = affectedServices.join(',')
                }
            }
        }

        stage('Build Microservices') {
            steps {
                script {
                    def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }.findAll { it }
                    
                    if (servicesToBuild.isEmpty()) {
                        echo "‚ÑπÔ∏è Aucun service √† builder"
                        currentBuild.result = 'SUCCESS'
                        return
                    }

                    // Construction s√©quentielle pour mieux g√©rer les d√©pendances
                    servicesToBuild.each { service ->
                        stage("Build ${service}") {
                            echo "üöÄ D√©clenchement du job pour ${service}"
                            try {
                                // V√©rifier si le job enfant existe
                                def jobExists = false
                                try {
                                    def job = Jenkins.instance.getItemByFullName("${service}-pipeline")
                                    jobExists = (job != null)
                                } catch (Exception e) {
                                    echo "‚ö†Ô∏è Impossible de v√©rifier l'existence du job ${service}-pipeline"
                                }

                                if (!jobExists) {
                                    echo "‚ùå Job ${service}-pipeline non trouv√©, cr√©ation simul√©e"
                                    // Simulation pour tests
                                    buildResults[service] = 'SUCCESS'
                                    buildState.services[service] = [
                                        status: 'SUCCESS',
                                        buildNumber: currentBuild.number,
                                        buildUrl: currentBuild.absoluteUrl,
                                        timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                                    ]
                                } else {
                                    def result = build(
                                        job: "${service}-pipeline",
                                        wait: true,
                                        propagate: false,
                                        parameters: []
                                    )

                                    def status = result.result.toString()
                                    echo "üîé R√©sultat ${service} : ${status}"

                                    buildResults[service] = status
                                    buildState.services[service] = [
                                        status: status,
                                        buildNumber: result.number,
                                        buildUrl: result.absoluteUrl,
                                        timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                                    ]
                                }

                            } catch (Exception e) {
                                echo "‚ùå Erreur lors du build de ${service} : ${e.message}"
                                buildResults[service] = 'FAILURE'
                                buildState.services[service] = [
                                    status: 'FAILURE',
                                    buildNumber: currentBuild.number,
                                    buildUrl: currentBuild.absoluteUrl,
                                    timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                                ]
                            }
                        }
                    }
                }
            }
        }

        stage('Sauvegarde √âtat') {
            steps {
                script {
                    // üíæ Sauvegarde de l'√©tat
                    if (buildState.services) {
                        def lines = buildState.services.collect { svc, info ->
                            "${svc}:${info.status}:${info.buildNumber}:${info.buildUrl}:${info.timestamp}"
                        }
                        writeFile file: env.BUILD_STATE_FILE, text: lines.join('\n')
                        archiveArtifacts artifacts: env.BUILD_STATE_FILE, fingerprint: true
                        echo "‚úÖ √âtat sauvegard√© dans ${env.BUILD_STATE_FILE}"
                    } else {
                        echo "‚ÑπÔ∏è Aucun √©tat √† sauvegarder"
                    }
                }
            }
        }
    }

    post {
        always {
            echo "üìä R√©sum√© final des builds :"
            script {
                if (buildResults) {
                    buildResults.each { service, result ->
                        def emoji = result == 'SUCCESS' ? '‚úÖ' : '‚ùå'
                        echo "${emoji} ${service} : ${result}"
                    }

                    def successCount = buildResults.count { k, v -> v == 'SUCCESS' }
                    def failureCount = buildResults.count { k, v -> v == 'FAILURE' }
                    def unstableCount = buildResults.count { k, v -> v == 'UNSTABLE' }
                    def abortedCount = buildResults.count { k, v -> v == 'ABORTED' }

                    echo "üìä TOTAL: ${buildResults.size()}, SUCC√àS: ${successCount}, √âCHECS: ${failureCount}, INSTABLES: ${unstableCount}, ABANDONN√âS: ${abortedCount}"
                    
                    // D√©finir le r√©sultat global du pipeline
                    if (failureCount > 0) {
                        currentBuild.result = 'FAILURE'
                    } else if (unstableCount > 0) {
                        currentBuild.result = 'UNSTABLE'
                    } else if (successCount > 0) {
                        currentBuild.result = 'SUCCESS'
                    }
                } else {
                    echo "‚ÑπÔ∏è Aucun r√©sultat de build √† afficher."
                }
            }
        }

        cleanup {
            // Nettoyage optionnel
            echo "üßπ Nettoyage de l'espace de travail"
        }
    }
}
