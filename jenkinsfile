def buildResults = [:]
def buildState = [services: [:]]

pipeline {
    agent any

    environment {
        SERVICES = 'service-node,service-python,frontend-react,gestion-prod-service'
        BUILD_STATE_FILE = '.build-state.txt'
        SLACK_CHANNEL = '#jenkins_devops_alert'
    }

    stages {
        stage('Pr√©paration') {
            steps {
                script {
                    // üîÅ Tentative de r√©cup√©ration de l'artefact pr√©c√©dent
                    try {
                        copyArtifacts(
                            projectName: env.JOB_NAME,
                            selector: lastSuccessful(),
                            filter: env.BUILD_STATE_FILE,
                            target: '.',
                            flatten: true
                        )
                        echo "‚úÖ Artefact r√©cup√©r√© avec succ√®s"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Impossible de restaurer l'artefact : ${e.message}"
                    }

                    // üîç D√©tection des fichiers modifi√©s via Git
                    def changedFiles = []
                    try {
                        // M√©thode plus robuste pour d√©tecter les changements
                        def changeLogSets = currentBuild.changeSets
                        if (changeLogSets && !changeLogSets.isEmpty()) {
                            changeLogSets.each { changeLogSet ->
                                changeLogSet.each { entry ->
                                    entry.affectedFiles.each { file ->
                                        changedFiles << file.path
                                    }
                                }
                            }
                        } else {
                            // Fallback: utiliser git difff
                            def gitDiff = sh(
                                script: 'git diff --name-only HEAD~1 HEAD 2>/dev/null || echo ""',
                                returnStdout: true
                            ).trim()
                            if (gitDiff) {
                                changedFiles = gitDiff.split('\n')
                            }
                        }
                        echo "üîç Fichiers modifi√©s d√©tect√©s : ${changedFiles}"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Erreur lors de la d√©tection des changements : ${e.message}"
                        changedFiles = []
                    }

                    // üß† Charger les services pr√©c√©demment en √©chec
                    def previousFailures = [] as Set
                    if (fileExists(env.BUILD_STATE_FILE)) {
                        def stateContent = readFile(env.BUILD_STATE_FILE).trim()
                        if (stateContent) {
                            stateContent.split('\n').each { line ->
                                def parts = line.split(':', 5)
                                if (parts.size() >= 2 && parts[1] == 'FAILURE') {
                                    previousFailures << parts[0]
                                }
                            }
                        }
                        echo "‚ö†Ô∏è Services pr√©c√©demment en √©chec : ${previousFailures}"
                    } else {
                        echo "‚ÑπÔ∏è Aucun fichier d'√©tat pr√©c√©dent trouv√©"
                    }

                    // üéØ D√©terminer les services affect√©s
                    def services = env.SERVICES.split(',').collect { it.trim() } as Set
                    def affectedServices = [] as Set

                    if (changedFiles) {
                        affectedServices = services.findAll { service ->
                            changedFiles.any { file -> 
                                file.startsWith("${service}/") || 
                                file.contains("/${service}/") ||
                                file.startsWith(service)
                            }
                        } as Set
                    }

                    // Ajouter les services pr√©c√©demment en √©chec
                    affectedServices.addAll(previousFailures)

                    // Si aucun service affect√©, builder tous les services
                    if (affectedServices.isEmpty()) {
                        echo "‚ÑπÔ∏è Aucun service affect√© d√©tect√©, construction de tous les services"
                        affectedServices = services
                    }

                    echo "üöÄ Services √† builder : ${affectedServices}"
                    env.AFFECTED_SERVICES = affectedServices.join(',')
                }
            }
        }

        stage('Build Microservices') {
            steps {
                script {
                    def branch = env.BRANCH_NAME ?: 'main'  // Branche actuelle ou 'main'
                    def servicesToBuild = env.AFFECTED_SERVICES.split(',')
                                                .collect { it.trim() }
                                                .findAll { it }

                    if (servicesToBuild.isEmpty()) {
                        echo "‚ÑπÔ∏è Aucun service √† builder"
                        currentBuild.result = 'SUCCESS'
                        return
                    }

                    // Construction s√©quentielle pour chaque service
                    servicesToBuild.each { service ->
                        stage("Build ${service}") {
                            def jobName = "${service}/${branch}"
                            echo "üöÄ D√©clenchement du job ${jobName}"

                            try {
                                def result = build(
                                    job: jobName,
                                    wait: true,
                                    propagate: false
                                )
                                def status = result?.result?.toString() ?: 'FAILURE'
                                echo "üîé R√©sultat ${jobName} : ${status}"

                                buildResults[service] = status
                                buildState.services[service] = [
                                    status: status,
                                    buildNumber: result.number,
                                    buildUrl: result.absoluteUrl,
                                    timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                                ]

                            } catch (Exception e) {
                                echo "‚ùå Impossible de lancer le job ${jobName} : ${e.message}"
                                buildResults[service] = 'FAILURE'
                                buildState.services[service] = [
                                    status: 'FAILURE',
                                    buildNumber: currentBuild.number,
                                    buildUrl: currentBuild.absoluteUrl,
                                    timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                                ]
                            }
                        }
                    }
                }
            }
        }


        stage('Sauvegarde √âtat') {
            steps {
                script {
                    // üíæ Sauvegarde de l'√©tat
                    if (buildState.services) {
                        def lines = buildState.services.collect { svc, info ->
                            "${svc}:${info.status}:${info.buildNumber}:${info.buildUrl}:${info.timestamp}"
                        }
                        writeFile file: env.BUILD_STATE_FILE, text: lines.join('\n')
                        archiveArtifacts artifacts: env.BUILD_STATE_FILE, fingerprint: true
                        echo "‚úÖ √âtat sauvegard√© dans ${env.BUILD_STATE_FILE}"
                    } else {
                        echo "‚ÑπÔ∏è Aucun √©tat √† sauvegarder"
                    }
                }
            }
        }
    }

    post {
        /*always {
            echo "üìä R√©sum√© final des builds :"
            script {
                if (buildResults) {
                    buildResults.each { service, result ->
                        def emoji = result == 'SUCCESS' ? '‚úÖ' : '‚ùå'
                        echo "${emoji} ${service} : ${result}"
                    }

                    def successCount = buildResults.count { k, v -> v == 'SUCCESS' }
                    def failureCount = buildResults.count { k, v -> v == 'FAILURE' }
                    def unstableCount = buildResults.count { k, v -> v == 'UNSTABLE' }
                    def abortedCount = buildResults.count { k, v -> v == 'ABORTED' }

                    echo "üìä TOTAL: ${buildResults.size()}, SUCC√àS: ${successCount}, √âCHECS: ${failureCount}, INSTABLES: ${unstableCount}, ABANDONN√âS: ${abortedCount}"
                    
                    // D√©finir le r√©sultat global du pipeline
                    if (failureCount > 0) {
                        currentBuild.result = 'FAILURE'
                    } else if (unstableCount > 0) {
                        currentBuild.result = 'UNSTABLE'
                    } else if (successCount > 0) {
                        currentBuild.result = 'SUCCESS'
                    }
                } else {
                    echo "‚ÑπÔ∏è Aucun r√©sultat de build √† afficher."
                }
            }
        }*/

        always {
            script {
                def buildSummary = "üìä *R√©sum√© du Pipeline Orchestrateur - Build #${env.BUILD_NUMBER}*\n"
                buildSummary += "*Statut global du pipeline orchestrateur :* ${currentBuild.result ?: 'INCONNU'}\n"
                buildSummary += "*Branche :* ${env.BRANCH_NAME ?: 'main'}\n"
                buildSummary += "*URL du build :* ${env.BUILD_URL}\n\n"
                
                if (buildResults && !buildResults.isEmpty()) {
                    buildSummary += "*D√©tail par service :*\n"
                    
                    buildResults.each { service, result ->
                        def emoji = result == 'SUCCESS' ? '‚úÖ' : (result == 'UNSTABLE' ? '‚ö†Ô∏è' : '‚ùå')
                        def serviceInfo = buildState.services[service]
                        if (serviceInfo) {
                            buildSummary += "${emoji} *${service}* : ${result} (<${serviceInfo.buildUrl}|#${serviceInfo.buildNumber}>)\n"
                        } else {
                            buildSummary += "${emoji} *${service}* : ${result}\n"
                        }
                    }
                    
                    def successCount = buildResults.count { k, v -> v == 'SUCCESS' }
                    def failureCount = buildResults.count { k, v -> v == 'FAILURE' }
                    def unstableCount = buildResults.count { k, v -> v == 'UNSTABLE' }
                    def abortedCount = buildResults.count { k, v -> v == 'ABORTED' }
                    def totalCount = buildResults.size()
                    
                    buildSummary += "\n*üìä Statistiques :*\n"
                    buildSummary += "‚Ä¢ Total services : ${totalCount}\n"
                    buildSummary += "‚Ä¢ ‚úÖ Succ√®s : ${successCount}\n"
                    buildSummary += "‚Ä¢ ‚ùå √âchecs : ${failureCount}\n"
                    buildSummary += "‚Ä¢ ‚ö†Ô∏è Instables : ${unstableCount}\n"
                    buildSummary += "‚Ä¢ ‚èπÔ∏è Abandonn√©s : ${abortedCount}\n"
                    
                    // Ajouter les services affect√©s
                    if (env.AFFECTED_SERVICES) {
                        buildSummary += "\n*üîç Services affect√©s :* ${env.AFFECTED_SERVICES}\n"
                    }
                } else {
                    buildSummary += "*‚ÑπÔ∏è Aucun service n'a √©t√© construit.*\n"
                }
                
                // Ajouter la dur√©e du build
                def duration = currentBuild.durationString ?: "N/A"
                buildSummary += "\n*‚è±Ô∏è Dur√©e :* ${duration}"
                
                // D√©terminer la couleur et l'emoji pour le message Slack
                def color = "good"  // vert par d√©faut
                def statusEmoji = "‚úÖ"
                
                if (currentBuild.result == 'FAILURE') {
                    color = "danger"
                    statusEmoji = "‚ùå"
                } else if (currentBuild.result == 'UNSTABLE') {
                    color = "warning"
                    statusEmoji = "‚ö†Ô∏è"
                } else if (currentBuild.result == 'ABORTED') {
                    color = "#808080"
                    statusEmoji = "‚èπÔ∏è"
                }
                
                // Envoyer la notification Slack
                slackSend(
                    channel: "${env.SLACK_CHANNEL}",
                    color: color,
                    message: "${statusEmoji} *Pipeline Orchestrateur - Build #${env.BUILD_NUMBER} - ${currentBuild.result ?: 'INCONNU'}*\n${buildSummary}",
                    footer: "Jenkins CI/CD",
                    mrkdwn: true
                )
                
                echo "üì§ Notification Slack envoy√©e avec le statut : ${currentBuild.result}"
            }
        }

        failure {
            slackSend(
                channel: "${env.SLACK_CHANNEL}",
                message: "‚ùå *Pipeline Orchestrateur* a √©chou√© dans le build #${env.BUILD_NUMBER}"
            )
        }

        success {
            slackSend(
                channel: "${env.SLACK_CHANNEL}",
                message: "üéâ *Pipeline Orchestrateur* r√©ussi pour le build #${env.BUILD_NUMBER}"
            )
        }
    }
 }
