def buildResults = [:]
def buildState = [services: [:]]

pipeline {
    agent any

    environment {
        SERVICES = 'service-node,service-python,frontend-react,gestion-prod-service'
        BUILD_STATE_FILE = '.build-state.txt'
        SLACK_CHANNEL = '#jenkins_devops_alert'
    }

    stages {
        stage('PrÃ©paration') {
            steps {
                script {
                    // ğŸ” Tentative de rÃ©cupÃ©ration de l'artefact prÃ©cÃ©dent
                    try {
                        copyArtifacts(
                            projectName: env.JOB_NAME,
                            selector: lastSuccessful(),
                            filter: env.BUILD_STATE_FILE,
                            target: '.',
                            flatten: true
                        )
                        echo "âœ… Artefact rÃ©cupÃ©rÃ© avec succÃ¨s"
                    } catch (Exception e) {
                        echo "âš ï¸ Impossible de restaurer l'artefact : ${e.message}"
                    }

                    // ğŸ” DÃ©tection des fichiers modifiÃ©s via Git
                    def changedFiles = []
                    try {
                        // MÃ©thode plus robuste pour dÃ©tecter les changements
                        def changeLogSets = currentBuild.changeSets
                        if (changeLogSets && !changeLogSets.isEmpty()) {
                            changeLogSets.each { changeLogSet ->
                                changeLogSet.each { entry ->
                                    entry.affectedFiles.each { file ->
                                        changedFiles << file.path
                                    }
                                }
                            }
                        } else {
                            // Fallback: utiliser git difff
                            def gitDiff = sh(
                                script: 'git diff --name-only HEAD~1 HEAD 2>/dev/null || echo ""',
                                returnStdout: true
                            ).trim()
                            if (gitDiff) {
                                changedFiles = gitDiff.split('\n')
                            }
                        }
                        echo "ğŸ” Fichiers modifiÃ©s dÃ©tectÃ©s : ${changedFiles}"
                    } catch (Exception e) {
                        echo "âš ï¸ Erreur lors de la dÃ©tection des changements : ${e.message}"
                        changedFiles = []
                    }

                    // ğŸ§  Charger les services prÃ©cÃ©demment en Ã©chec
                    def previousFailures = [] as Set
                    if (fileExists(env.BUILD_STATE_FILE)) {
                        def stateContent = readFile(env.BUILD_STATE_FILE).trim()
                        if (stateContent) {
                            stateContent.split('\n').each { line ->
                                def parts = line.split(':', 5)
                                if (parts.size() >= 2 && parts[1] == 'FAILURE') {
                                    previousFailures << parts[0]
                                }
                            }
                        }
                        echo "âš ï¸ Services prÃ©cÃ©demment en Ã©chec : ${previousFailures}"
                    } else {
                        echo "â„¹ï¸ Aucun fichier d'Ã©tat prÃ©cÃ©dent trouvÃ©"
                    }

                    // ğŸ¯ DÃ©terminer les services affectÃ©s
                    def services = env.SERVICES.split(',').collect { it.trim() } as Set
                    def affectedServices = [] as Set

                    if (changedFiles) {
                        affectedServices = services.findAll { service ->
                            changedFiles.any { file -> 
                                file.startsWith("${service}/") || 
                                file.contains("/${service}/") ||
                                file.startsWith(service)
                            }
                        } as Set
                    }

                    // Ajouter les services prÃ©cÃ©demment en Ã©chec
                    affectedServices.addAll(previousFailures)

                    // Si aucun service affectÃ©, builder tous les services
                    if (affectedServices.isEmpty()) {
                        echo "â„¹ï¸ Aucun service affectÃ© dÃ©tectÃ©, construction de tous les services"
                        affectedServices = services
                    }

                    echo "ğŸš€ Services Ã  builder : ${affectedServices}"
                    env.AFFECTED_SERVICES = affectedServices.join(',')
                }
            }
        }

        stage('Build Microservices') {
            steps {
                script {
                    def branch = env.BRANCH_NAME ?: 'main'  // Branche actuelle ou 'main'
                    def servicesToBuild = env.AFFECTED_SERVICES.split(',')
                                                .collect { it.trim() }
                                                .findAll { it }

                    if (servicesToBuild.isEmpty()) {
                        echo "â„¹ï¸ Aucun service Ã  builder"
                        currentBuild.result = 'SUCCESS'
                        return
                    }

                    // Construction sÃ©quentielle pour chaque service
                    servicesToBuild.each { service ->
                        stage("Build ${service}") {
                            def jobName = "${service}/${branch}"
                            echo "ğŸš€ DÃ©clenchement du job ${jobName}"

                            try {
                                def result = build(
                                    job: jobName,
                                    wait: true,
                                    propagate: false
                                )
                                def status = result?.result?.toString() ?: 'FAILURE'
                                echo "ğŸ” RÃ©sultat ${jobName} : ${status}"

                                buildResults[service] = status
                                buildState.services[service] = [
                                    status: status,
                                    buildNumber: result.number,
                                    buildUrl: result.absoluteUrl,
                                    timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                                ]

                            } catch (Exception e) {
                                echo "âŒ Impossible de lancer le job ${jobName} : ${e.message}"
                                buildResults[service] = 'FAILURE'
                                buildState.services[service] = [
                                    status: 'FAILURE',
                                    buildNumber: currentBuild.number,
                                    buildUrl: currentBuild.absoluteUrl,
                                    timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                                ]
                            }
                        }
                    }
                }
            }
        }


        stage('Sauvegarde Ã‰tat') {
            steps {
                script {
                    // ğŸ’¾ Sauvegarde de l'Ã©tat
                    if (buildState.services) {
                        def lines = buildState.services.collect { svc, info ->
                            "${svc}:${info.status}:${info.buildNumber}:${info.buildUrl}:${info.timestamp}"
                        }
                        writeFile file: env.BUILD_STATE_FILE, text: lines.join('\n')
                        archiveArtifacts artifacts: env.BUILD_STATE_FILE, fingerprint: true
                        echo "âœ… Ã‰tat sauvegardÃ© dans ${env.BUILD_STATE_FILE}"
                    } else {
                        echo "â„¹ï¸ Aucun Ã©tat Ã  sauvegarder"
                    }
                }
            }
        }
    }

    /*post {
        always {
            echo "ğŸ“Š RÃ©sumÃ© final des builds :"
            script {
                if (buildResults) {
                    buildResults.each { service, result ->
                        def emoji = result == 'SUCCESS' ? 'âœ…' : 'âŒ'
                        echo "${emoji} ${service} : ${result}"
                    }

                    def successCount = buildResults.count { k, v -> v == 'SUCCESS' }
                    def failureCount = buildResults.count { k, v -> v == 'FAILURE' }
                    def unstableCount = buildResults.count { k, v -> v == 'UNSTABLE' }
                    def abortedCount = buildResults.count { k, v -> v == 'ABORTED' }

                    echo "ğŸ“Š TOTAL: ${buildResults.size()}, SUCCÃˆS: ${successCount}, Ã‰CHECS: ${failureCount}, INSTABLES: ${unstableCount}, ABANDONNÃ‰S: ${abortedCount}"
                    
                    // DÃ©finir le rÃ©sultat global du pipeline
                    if (failureCount > 0) {
                        currentBuild.result = 'FAILURE'
                    } else if (unstableCount > 0) {
                        currentBuild.result = 'UNSTABLE'
                    } else if (successCount > 0) {
                        currentBuild.result = 'SUCCESS'
                    }
                } else {
                    echo "â„¹ï¸ Aucun rÃ©sultat de build Ã  afficher."
                }
            }
        }

        cleanup {
            // Nettoyage optionnel
            echo "ğŸ§¹ Nettoyage de l'espace de travail"
        }
    }*/

    post {
        always {
            echo "ğŸ“Š RÃ©sumÃ© final des builds :"
            script {
                if (buildResults) {
                    buildResults.each { service, result ->
                        def emoji = result == 'SUCCESS' ? 'âœ…' : 'âŒ'
                        echo "${emoji} ${service} : ${result}"
                    }

                    def successCount = buildResults.count { k, v -> v == 'SUCCESS' }
                    def failureCount = buildResults.count { k, v -> v == 'FAILURE' }
                    def unstableCount = buildResults.count { k, v -> v == 'UNSTABLE' }
                    def abortedCount = buildResults.count { k, v -> v == 'ABORTED' }

                    echo "ğŸ“Š TOTAL: ${buildResults.size()}, SUCCÃˆS: ${successCount}, Ã‰CHECS: ${failureCount}, INSTABLES: ${unstableCount}, ABANDONNÃ‰S: ${abortedCount}"

                    // RÃ©sultat global
                    if (failureCount > 0) {
                        currentBuild.result = 'FAILURE'
                    } else if (unstableCount > 0) {
                        currentBuild.result = 'UNSTABLE'
                    } else if (successCount > 0) {
                        currentBuild.result = 'SUCCESS'
                    }

                    // ğŸ”¥ğŸ”¥ğŸ”¥ Envoi Alert Slack ğŸ”¥ğŸ”¥ğŸ”¥
                    def summaryMessage = "*ğŸ”” RÃ©sultat pipeline Orchestrateur â€” Build #${env.BUILD_NUMBER}*\n"
                    summaryMessage += "> ğŸ“… *Date:* ${new Date().format("yyyy-MM-dd HH:mm")}\n"
                    summaryMessage += "> ğŸ‘¤ *DÃ©clenchÃ© par:* ${currentBuild.rawBuild.getCauses()[0].shortDescription}\n\n"

                    buildResults.each { service, result ->
                        def emoji = result == 'SUCCESS' ? 'ğŸŸ¢' : 'ğŸ”´'
                        summaryMessage += "${emoji} *${service}* â†’ *${result}*\n"
                    }

                    summaryMessage += "\n*ğŸ“¦ RÃ©sultat global:* `${currentBuild.result}`"

                    slackSend(
                        channel: "${env.SLACK_CHANNEL}",
                        message: summaryMessage
                    )
                }
            }
        }

        failure {
            slackSend(
                channel: "${env.SLACK_CHANNEL}",
                message: "âŒ *Pipeline Orchestrateur* a Ã©chouÃ© dans le build #${env.BUILD_NUMBER}"
            )
        }

        success {
            slackSend(
                channel: "${env.SLACK_CHANNEL}",
                message: "ğŸ‰ *Pipeline Orchestrateur* rÃ©ussi pour le build #${env.BUILD_NUMBER}"
            )
        }
    }
 }
