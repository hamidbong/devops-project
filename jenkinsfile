def buildResults = [:]
def buildState = [services: [:]]

pipeline {
    agent any

    environment {
        SERVICES = 'service-node,service-python,frontend-react,service-java'
        BUILD_STATE_FILE = '.build-state.txt'
    }

    stages {
        stage('Pr√©paration') {
            steps {
                script {
                    // üîÅ Tentative de r√©cup√©ration de l'artefact pr√©c√©dent
                    try {
                        copyArtifacts(
                            projectName: env.JOB_NAME,
                            selector: specific(lastSuccessfulBuildId()),
                            filter: env.BUILD_STATE_FILE,
                            target: '.',
                            flatten: true
                        )
                        echo "‚úÖ Artefact r√©cup√©r√© avec succ√®s"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Impossible de restaurer l'artefact : ${e.message}"
                    }

                    // üîç D√©tection des fichiers modifi√©s via Git
                    def changedFiles = []
                    try {
                        def gitDiff = sh(
                            script: 'git diff --name-only HEAD~1 HEAD 2>/dev/null || git ls-tree -r HEAD --name-only',
                            returnStdout: true
                        ).trim()
                        
                        changedFiles = gitDiff ? gitDiff.split('\n') : []
                        echo "üîç Fichiers modifi√©s d√©tect√©s : ${changedFiles.size()}"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Erreur lors de la d√©tection des changements : ${e.message}"
                        changedFiles = []
                    }

                    // üß† Charger les services pr√©c√©demment en √©chec
                    def previousFailures = [] as Set
                    if (fileExists(env.BUILD_STATE_FILE)) {
                        def stateContent = readFile(env.BUILD_STATE_FILE).trim()
                        if (stateContent) {
                            stateContent.split('\n').each { line ->
                                def parts = line.split(':', 5)
                                if (parts.size() >= 2 && parts[1] == 'FAILURE') {
                                    previousFailures << parts[0]
                                }
                            }
                        }
                        echo "‚ö†Ô∏è Services pr√©c√©demment en √©chec : ${previousFailures}"
                    }

                    // üéØ D√©terminer les services affect√©s
                    def services = env.SERVICES.split(',').collect { it.trim() } as Set
                    def affectedServices = services.findAll { service ->
                        changedFiles.any { file -> 
                            file.startsWith("${service}/") || 
                            file.contains("/${service}/")
                        }
                    } as Set
                    
                    // Ajouter les services pr√©c√©demment en √©chec
                    affectedServices.addAll(previousFailures)

                    if (affectedServices.isEmpty()) {
                        echo "‚ÑπÔ∏è Aucun service affect√© d√©tect√©, construction de tous les services"
                        affectedServices = services
                    }

                    echo "üöÄ Services √† builder : ${affectedServices}"
                    env.AFFECTED_SERVICES = affectedServices.join(',')
                }
            }
        }

        stage('Build Microservices') {
            steps {
                script {
                    def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }.findAll { it }
                    
                    if (servicesToBuild.isEmpty()) {
                        echo "‚ÑπÔ∏è Aucun service √† builder"
                        currentBuild.result = 'SUCCESS'
                        return
                    }

                    parallel servicesToBuild.collectEntries { service ->
                        ["${service}": {
                            stage("Build ${service}") {
                                echo "üöÄ D√©clenchement du job pour ${service}"
                                try {
                                    def result = build(
                                        job: "${service}-pipeline",
                                        wait: true,
                                        propagate: false,
                                        parameters: []
                                    )

                                    def status = result.result.toString()
                                    echo "üîé R√©sultat ${service} : ${status}"

                                    buildResults[service] = status
                                    buildState.services[service] = [
                                        status: status,
                                        buildNumber: result.number,
                                        buildUrl: result.absoluteUrl,
                                        timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                                    ]

                                } catch (Exception e) {
                                    echo "‚ùå Erreur lors du build de ${service} : ${e.message}"
                                    buildResults[service] = 'FAILURE'
                                    buildState.services[service] = [
                                        status: 'FAILURE',
                                        buildNumber: currentBuild.number,
                                        buildUrl: currentBuild.absoluteUrl,
                                        timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                                    ]
                                }
                            }
                        }]
                    }
                }
            }
        }

        stage('Sauvegarde √âtat') {
            steps {
                script {
                    // üíæ Sauvegarde de l'√©tat
                    def lines = buildState.services.collect { svc, info ->
                        "${svc}:${info.status}:${info.buildNumber}:${info.buildUrl}:${info.timestamp}"
                    }
                    writeFile file: env.BUILD_STATE_FILE, text: lines.join('\n')
                    archiveArtifacts artifacts: env.BUILD_STATE_FILE, fingerprint: true
                    echo "‚úÖ √âtat sauvegard√© dans ${env.BUILD_STATE_FILE}"
                }
            }
        }
    }

    post {
        always {
            echo "üìä R√©sum√© final des builds :"
            script {
                if (buildResults) {
                    buildResults.each { service, result ->
                        echo "üîé ${service} : ${result}"
                    }

                    def successCount = buildResults.count { k, v -> v == 'SUCCESS' }
                    def failureCount = buildResults.count { k, v -> v == 'FAILURE' }
                    def unstableCount = buildResults.count { k, v -> v == 'UNSTABLE' }
                    def abortedCount = buildResults.count { k, v -> v == 'ABORTED' }

                    echo "üìä TOTAL: ${buildResults.size()}, SUCC√àS: ${successCount}, √âCHECS: ${failureCount}, INSTABLES: ${unstableCount}, ABANDONN√âS: ${abortedCount}"
                    
                    // D√©finir le r√©sultat global du pipeline
                    if (failureCount > 0) {
                        currentBuild.result = 'FAILURE'
                    } else if (unstableCount > 0) {
                        currentBuild.result = 'UNSTABLE'
                    } else {
                        currentBuild.result = 'SUCCESS'
                    }
                } else {
                    echo "‚ÑπÔ∏è Aucun r√©sultat de build √† afficher."
                }
            }
        }

        cleanup {
            // Nettoyage des fichiers temporaires
            cleanWs()
        }
    }
}
