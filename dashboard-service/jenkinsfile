def SERVICE_NAME = 'dashboard-service'  // adapter au nom de ton service

pipeline {
    agent any

    environment {
        SONARQUBE   = 'sonarqube_devops_master_analyse'
        IMAGE_NAME  = "hamidbong/${SERVICE_NAME}"
        TRIVY_CACHE = 'trivy_cache'
        PYTHONPATH  = "${WORKSPACE}/${SERVICE_NAME}"  // Full absolute path
    }

    stages {

        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Install Dependencies') {
            steps {
                dir("${SERVICE_NAME}") {
                    sh 'python3 -m venv venv'
                    sh '. venv/bin/activate && pip install --upgrade pip'
                    sh '. venv/bin/activate && pip install -r requirements.txt --force-reinstall'
                }
            }
        }

        stage('Run Unit Tests') {
            steps {
                dir("${SERVICE_NAME}") {
                    sh '''
                        . venv/bin/activate
                        export PYTHONPATH=$PYTHONPATH:$(pwd)
                        pip install -e .
                        pytest --junitxml=test-results.xml --cov=app --cov-report=xml
                    '''
                }
            }
        }

        stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv("${SONARQUBE}") {
                    script {
                        sh """
                            ${tool('SonarScanner')}/bin/sonar-scanner \
                                -Dsonar.projectKey=${SERVICE_NAME} \
                                -Dsonar.projectName=${SERVICE_NAME} \
                                -Dsonar.sources=${SERVICE_NAME} \
                                -Dsonar.python.coverage.reportPaths=coverage.xml \
                                -Dsonar.projectVersion=${env.BUILD_NUMBER}
                        """
                    }
                }
            }
        }

        stage("Quality Gates") {
            steps {
                retry(5) {
                    timeout(time: 1, unit: 'MINUTES') {
                        waitForQualityGate abortPipeline: true
                    }
                    sleep(time: 5, unit: 'SECONDS')
                }
            }
        }

        stage('Trivy Filesystem Scan') {
            steps {
                dir("${SERVICE_NAME}") {
                    sh '''
                        docker run --rm \
                            -v $(pwd):/scan \
                            aquasec/trivy fs \
                            --security-checks vuln,config \
                            --output trivy-Filesystem-report.json \
                            /scan
                        archiveArtifacts artifacts: 'trivy-Filesystem-report.json', allowEmptyArchive: true
                    '''
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                dir("${SERVICE_NAME}") {
                    script {
                        dockerImage = docker.build("${IMAGE_NAME}:${env.BUILD_ID}")
                    }
                }
            }
        }

        stage('Setup Trivy Caches') {
            steps {
                sh 'docker volume create --name trivy_cache || true'
                sh 'docker volume create --name trivy_javadb_cache || true'
            }
        }

        stage('Scan Docker Image with Trivy') {
            steps {
                sh '''
                    docker run --rm \
                        -v /var/run/docker.sock:/var/run/docker.sock \
                        -v trivy_cache:/root/.cache/trivy \
                        -v $(pwd):/project \
                        aquasec/trivy:latest \
                        image ${IMAGE_NAME}:${BUILD_ID} \
                        --ignore-unfixed \
                        --format json \
                        --output /project/trivy-report.json
                '''
                archiveArtifacts artifacts: 'trivy-report.json', allowEmptyArchive: true
            }
        }

        stage('Push Docker Image') {
            steps {
                dir("${SERVICE_NAME}") {
                    script {
                        docker.withRegistry('https://index.docker.io/v1/', 'dockerHub-login') {
                            dockerImage.push()
                            dockerImage.push('latest')
                        }
                    }
                }
            }
        }

        stage('Cleanup Docker') {
            steps {
                sh "docker rmi ${IMAGE_NAME}:${env.BUILD_ID} || true"
                sh "docker rmi ${IMAGE_NAME}:latest || true"
                sh "docker image prune -f || true"
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                withKubeConfig([credentialsId: 'kubeconfig']) {
                    sh """
                        cat k8s/${SERVICE_NAME}/deployment.yaml | \
                        sed "s/{{BUILD_NUMBER}}/${env.BUILD_ID}/g" | kubectl apply -f -
                        kubectl apply -f k8s/${SERVICE_NAME}/service.yaml
                    """
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                withKubeConfig([credentialsId: 'kubeconfig']) {
                    sh "kubectl rollout status deployment/${SERVICE_NAME}-deployment --timeout=300s"
                    sh "kubectl wait --for=condition=ready pod -l app=${SERVICE_NAME} --timeout=300s"
                }
            }
        }

        stage('Git Tag') {
            when {
                branch 'main'
            }
            steps {
                script {
                    def versionTag = "v${env.BUILD_NUMBER}"
                    sh 'git config user.name "Jenkins CI"'
                    sh 'git config user.email "jenkins@example.com"'
                    sh "git tag ${versionTag}"
                    sh "git push origin ${versionTag}"
                }
            }
        }
    }

    post {
        always {
            archiveArtifacts artifacts: '**/coverage.xml,**/test-results.xml', allowEmptyArchive: true
            echo "üì¶ Build #${env.BUILD_NUMBER} completed"
        }
        success {
            echo '‚úÖ Pipeline completed successfully'
        }
        failure {
            echo '‚ùå Pipeline failed'
        }
    }
}
