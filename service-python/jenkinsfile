def SERVICE_NAME = 'service-python'  // adapter au nom de ton service

pipeline {
    agent any

    environment {
        AUTH_TOKEN_SONAR = credentials('SONAR_AUTH_TOKEN')
        IMAGE_NAME  = "hamidbong/${SERVICE_NAME}"
        TRIVY_CACHE = 'trivy_cache'
        PYTHONPATH  = "${WORKSPACE}/${SERVICE_NAME}"  // Full absolute pathh
        PYTHON_VERSION = '3.12.3'
    }

    stages {

        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Run Tests') {
            steps {
                dir("${SERVICE_NAME}") {
                    sh '''
                        python3 -m venv venv
                        . venv/bin/activate
                        pip install --upgrade pip
                        pip install -r requirements.txt
                        pip install pytest pytest-cov

                        pytest --cov=./ --cov-report=xml:coverage.xml --junitxml=test-results.xml -v
                    '''
                }
                archiveArtifacts artifacts: "${SERVICE_NAME}/test-results.xml,${SERVICE_NAME}/coverage.xml", allowEmptyArchive: true
            }
        }


        /*stage('OWASP Dependency-Check') {
            steps {
                dir("${SERVICE_NAME}") {
                    withCredentials([string(credentialsId: 'nvd-api-key', variable: 'NVD_API_KEY')]) {
                        dependencyCheck additionalArguments: '''
                            -s . 
                            -o "./dependency-check-report" 
                            -f ALL 
                            --prettyPrint 
                            --nvdApiKey=${NVD_API_KEY}''',
                            odcInstallation: 'dependency-check-12.1.9'
                    }

                    dependencyCheckPublisher pattern: 'dependency-check-report/dependency-check-report.xml',
                        failedTotalCritical: 1,
                        unstableTotalHigh: 1

                    archiveArtifacts artifacts: 'dependency-check-report/**', allowEmptyArchive: true
                }
            }
        }

        stage('Vérification vulnérabilités') {
            steps {
                script {
                    def report = readFile("${SERVICE_NAME}/dependency-check-report/dependency-check-report.xml")
                    if (report.contains('<baseSeverity>CRITICAL</baseSeverity>') || report.contains('<severity>critical</severity>')) {
                        error("Vulnérabilités CRITIQUES détectées — arrêt du pipeline.")
                    }
                }
            }
        }

       

        stage("Quality Gates") {
            steps {
                retry(4) {
                    timeout(time: 2, unit: 'MINUTES') {
                        script {
                            def qg = waitForQualityGate()
                            if (qg.status != 'OK') {
                                error "Pipeline aborted due to quality gate failure: ${qg.status}"
                            }
                        }
                    }
                }
            }
        }*/


        stage('Check Docker Daemon') {
            steps {
                sh 'docker version'
            }
        }

        stage('Build Docker Image') {
            steps {
                dir("${SERVICE_NAME}") {
                    script {
                        dockerImage = docker.build("${IMAGE_NAME}:${env.BUILD_ID}")
                    }
                }
            }
        }
        

        stage('Setup Trivy Caches') {
            steps {
                sh 'docker volume create --name trivy_cache || true'
                sh 'docker volume create --name trivy_javadb_cache || true'
            }
        }

        stage('Scan Docker Image with Trivy') {
            steps {
                sh '''
                    docker run --rm \
                        -v /var/run/docker.sock:/var/run/docker.sock \
                        -v trivy_cache:/root/.cache/trivy \
                        -v $(pwd):/project \
                        aquasec/trivy:latest \
                        image ${IMAGE_NAME}:${BUILD_ID} \
                        --exit-code 1 \
                        --severity CRITICAL,HIGH \
                        --ignore-unfixed \
                        --format json \
                        --output /project/trivy-report.json
                '''
                archiveArtifacts artifacts: 'trivy-report.json', allowEmptyArchive: true
            }
        }

        stage('Push Docker Image') {
            steps {
                dir("${SERVICE_NAME}") {
                    script {
                        docker.withRegistry('https://index.docker.io/v1/', 'dockerHub-login') {
                            dockerImage.push()
                            dockerImage.push('latest')
                        }
                    }
                }
            }
        }

        stage('Cleanup Docker') {
            steps {
                sh "docker rmi ${IMAGE_NAME}:${env.BUILD_ID} || true"
                sh "docker rmi ${IMAGE_NAME}:latest || true"
                sh "docker image prune -f || true"
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                withKubeConfig([credentialsId: 'kubeconfig']) {
                    sh """
                        kubectl cluster-info
                        cat k8s/${SERVICE_NAME}/deployment.yaml | \
                        sed "s/{{BUILD_NUMBER}}/${env.BUILD_ID}/g" | kubectl apply -f -
                        kubectl apply -f k8s/${SERVICE_NAME}/service.yaml
                        kubectl apply -f k8s/ingress-microservices.yaml

                    """
                }
            }
        }
        
        stage('Verify Deployment') {
            steps {
                withKubeConfig([credentialsId: 'kubeconfig']) {
                    sh "kubectl rollout status deployment/deployment-${SERVICE_NAME} --timeout=300s"
                    sh "kubectl wait --for=condition=ready pod -l app=deployment-${SERVICE_NAME} --timeout=300s"
                }
            }
        }

        stage('Git Tag') {
            when {
                branch 'main'
            }
            steps {
                withCredentials([usernamePassword(credentialsId: 'github-login', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')]) {
                    sh """
                        # Déshallow pour pouvoir taguer
                        git fetch --unshallow || echo 'déjà complet'

                        # Config Git pour Jenkins
                        git config user.name "Jenkins CI"
                        git config user.email "brahbong@gmail.com"

                        # Tag basé sur le numéro du build
                        VERSION_TAG="v${BUILD_NUMBER}"

                        # Création du tag
                        git tag \$VERSION_TAG

                        # Push sécurisé (HTTPS + token)
                        git push https://\$GIT_USER:\$GIT_PASS@github.com/hamidbong/devops-project.git \$VERSION_TAG
                    """
                }
            }
        }

    }

    post {
        success {
            slackSend (
                channel: "${env.SLACK_CHANNEL}",
                message: "✅ *${env.JOB_NAME}* #${env.BUILD_NUMBER} a réussi : ${env.BUILD_URL}",
                color: 'good'
            )
        }

        failure {
            slackSend (
                channel: "${env.SLACK_CHANNEL}",
                message: "❌ *${env.JOB_NAME}* #${env.BUILD_NUMBER} a échoué : ${env.BUILD_URL}",
                color: 'danger'
            )
        }

        always {
            echo 'Pipeline terminé.'
        }
    }
}
